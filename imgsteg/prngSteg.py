from PIL import Image
import math
import random
import numpy as np
PATH_TO_DIR = r'C:\Users\Ow me back\AppData\Local\atom\app-1.41.0\imgsteg'
import os
import hashlib
#loading in the image
os.chdir(PATH_TO_DIR)
image = Image.open("waterfall.png")

#getting pixels
pixels = image.load()

# ----- function definitions here -----

# determines the number of bits for a String message
def determineNumBits(message):
    chars = len(message) # number of characters
    length = chars*8 # each character is represented by a byte (8 bits)
    return length

# determines the maximum amount of characters a message can have
def maxMessage(im):
    (width, height) = im.size # getting both width and height
    num_pixels = width*height # determining the number of pixels
    max = (num_pixels-1)/8 # each pixel can store 9 bits of information, but each letter will have 8 bits for it; minus 1 for the message length
    return math.floor(max) # round down as we need only the full amount of 8 bits words we can store

# converts a message into a String of bits
# each group of 8 bits represents a character in the input message
def messageToBits(message):
    length = len(message) # number of characters in the message
    bits = "" # string representing the bit representation of the message, initially empty
    for i in range (0,length): # loop for each character
        asciiValue = ord(message[i]) # get ascii value of each character
        currBinary = f'{asciiValue:08b}' # convert current ascii value to an 8-bit binary number
        if(i<length): # if we still have more to the message, add a space
            bits += currBinary + " "
        else: # otherwise, we are at the end, do not add a space
            bits += currBinary
    return bits

# returns a list of the pixels that need to be modified
# returns the pixels as if they were listed in a one-dimensional array
# use another function (oneDtoTwoDPixel) to convert to a [row, column] representation
def generateNRandomPixels(msgsize, seed, im):
    width, height = im.size # get width and height
    max = width*height # get the number of pixels (this minus 1 also refers to the last pixel)
    randomList = list(range(0,max)) # a list of numbers from 0 to one less than the total number of pixels in the image; each number in the list represents a pixel in the original image
    random.seed(seed) # set the seed to use for the PRNG
    random.shuffle(randomList) # shuffle using the seed
    numPixelsWeNeed = msgsize//2  # need an extra to store the message length! storing in last 2 bits of each pixel
    neededPixels = randomList[0:numPixelsWeNeed] # get the pixels we need first numPixelsWeNeed from the random list
    return neededPixels

# takes in a pixel, represented by one value (one-dimensional array), and transforms it into a two-dimensional representation [row, column]
# IMPORTANT: when using the returned row and column, must access the pixel in the reverse manner [column, row]
def oneDtoTwoDPixel(pixelNumber, im):
    width, _ = im.size # only need width, ignore height
    x = 0
    y = 0
    while not (pixelNumber >= 0) & (pixelNumber < width):
        pixelNumber -= width
        x += 1 # increment - this keeps track of the row
    y = pixelNumber # the column is the value of y
    return [x,y]

# takes in the list of random pixels (one-dimensional representation) and returns a list of the two-dimensional representations
def listOfRandomPixels(randPixels, im):
    result = [(oneDtoTwoDPixel(pixel, im)) for pixel in randPixels] # convert each 1D pixel to 2D representation and add to the list
    return result


# generates a 64 bit number to be used as the seed for randomization
# the seed is generated by first hashing the secret key using the md5 algorithm
# once, hashed, the first 64 bits of output are converted to an int - this is the seed
def generateSeed(message):
    hash = hashlib.md5(message.encode()) # hash our secret key using md5
    digest = hash.hexdigest()[0:16] # convert the hash to hex and extract the first 16 bytes
    newSeed = int(digest, 16) # convert the hex to an int
    return newSeed

# ----- testing here -----
'''
message = "hello world, it's me, Justin!" # random message
seed = generateSeed(message)
#7387601733595079284
seed = generateSeed(message)
print(seed == 7387601733595079284)
'''
#result = generateAllRandomPixels(seed, image)
#print(result)
'''
randList = result
r = listOfRandomPixels(randList, image)
print(r)
print(len(r) == len(message)//2 +1)
'''

# returns a list of all pixels in a random order - IGNORES the first 16 pixels
# returns the pixels as if they were listed in a one-dimensional array
# use another function (oneDtoTwoDPixel) to convert to a [row, column] representation
def generateAllRandomPixels(seed, im):
    width, height = im.size # get width and height
    max = width*height # get the number of pixels (this minus 1 also refers to the last pixel)
    randomList = list(range(16,max)) # a list of numbers from 16 to one less than the total number of pixels in the image; each number in the list represents a pixel in the original image
    random.seed(seed) # set the seed to use for the PRNG
    random.shuffle(randomList) # shuffle using the seed
    neededPixels = randomList[0:len(randomList)] # get the pixels we need - first numPixelsWeNeed from the random list
    return neededPixels
